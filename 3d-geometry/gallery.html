<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ì–∞–ª–µ—Ä–µ—è 3D —Ç–µ–ª</title>
    <link rel="stylesheet" href="style.css">
    <style>
        /* –°—Ç–∏–ª–∏ –¥–ª—è –ø–∞–Ω–µ–ª–∏ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ */
        .elements-panel {
            position: absolute;
            top: 80px;
            right: 20px;
            background: rgba(68, 68, 68, 0.95);
            padding: 20px;
            border-radius: 8px;
            z-index: 100;
            border: 1px solid #555;
            width: 280px;
            color: white;
            font-family: Arial, sans-serif;
            backdrop-filter: blur(10px);
            max-height: 70vh;
            overflow-y: auto;
        }
        
        .elements-panel h3 {
            margin-top: 0;
            color: #ADFF2F;
            border-bottom: 1px solid #555;
            padding-bottom: 10px;
            font-size: 16px;
            text-align: center;
        }
        
        .element-section {
            margin-bottom: 20px;
        }
        
        .element-section h4 {
            color: #ADFF2F;
            margin-bottom: 8px;
            font-size: 14px;
            text-align: center;
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
        }
        
        .element-list {
            font-size: 12px;
            line-height: 1.4;
            color: #ccc;
        }
        
        .element-item {
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: all 0.3s ease;
            display: inline-block;
            margin: 2px;
            border: 1px solid transparent;
            background: rgba(255, 255, 255, 0.1);
        }
        
        .element-item:hover {
            background: rgba(173, 255, 47, 0.3);
            border-color: #ADFF2F;
            transform: translateY(-2px);
        }
        
        .element-item.highlighted {
            background: #ADFF2F;
            color: #2d2d2d;
            font-weight: bold;
            border-color: #ADFF2F;
            box-shadow: 0 0 10px rgba(173, 255, 47, 0.5);
        }

        .label {
            position: absolute;
            color: #fff;
            font-weight: bold;
            font-size: 14px;
            pointer-events: none;
            z-index: 10;
            background: rgba(68, 68, 68, 0.9);
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid #555;
        }

        .hidden {
            display: none !important;
        }

        /* –ï–¥–∏–Ω—ã–π —Å—Ç–∏–ª—å –¥–ª—è –≤—Å–µ—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –ø–∞–Ω–µ–ª–∏ */
        .elements-content {
            text-align: center;
        }
        
        .elements-content .element-item {
            margin: 3px;
            min-width: 40px;
            text-align: center;
        }
    </style>
    <!-- ==================== –ü–û–î–ö–õ–Æ–ß–ï–ù–ò–ï THREE.JS ==================== -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <!-- ==================== –®–ê–ü–ö–ê –°–ê–ô–¢–ê ==================== -->
    <header class="header">
        <div class="container">
             <div class="logo-container">
                 <img src="pict/logo.png" alt="3D Geometry Logo" class="logo-image">
                 <h1 class="logo">3D Geometry</h1>
             </div>
            <nav class="nav">
                <a href="index.html">–ì–ª–∞–≤–Ω–∞—è</a>
                <a href="gallery.html" class="active">–ì–∞–ª–µ—Ä–µ—è</a>
                <a href="formulas.html">–§–∏–≥—É—Ä—ã</a>
                <a href="about.html">–û –ø—Ä–æ–µ–∫—Ç–µ</a>
            </nav>
        </div>
    </header>

    <main class="main">
        <div class="container">
            <h2>–ì–∞–ª–µ—Ä–µ—è –≥–µ–æ–º–µ—Ç—Ä–∏—á–µ—Å–∫–∏—Ö —Ç–µ–ª</h2>
            <p>–ò—Å—Å–ª–µ–¥—É–π—Ç–µ –∫–æ–ª–ª–µ–∫—Ü–∏—é —Ç—Ä–µ—Ö–º–µ—Ä–Ω—ã—Ö –≥–µ–æ–º–µ—Ç—Ä–∏—á–µ—Å–∫–∏—Ö —Ñ–∏–≥—É—Ä. </p>
            <p>–ù–∞–∂–º–∏—Ç–µ –Ω–∞ –ª—é–±—É—é –∫–∞—Ä—Ç–æ—á–∫—É –¥–ª—è –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ–≥–æ 3D –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ —Å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å—é –≤—Ä–∞—â–µ–Ω–∏—è –∏ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—è.</p> 
            
            <!-- ==================== –ì–ê–õ–ï–†–ï–Ø –§–ò–ì–£–† ==================== -->
            <div class="gallery-grid">
                <!-- –§–∏–≥—É—Ä–∞ 0: –ö—É–± -->
                <div class="gallery-card" data-shape="0">
                    <h3>–ö—É–±</h3>
                    <div class="card-image">
                        <img src="pict/kub.png" alt="–ö—É–±" class="shape-image">
                    </div>
                </div>

                <!-- –§–∏–≥—É—Ä–∞ 1: –ü–∞—Ä–∞–ª–ª–µ–ª–µ–ø–∏–ø–µ–¥ -->
                <div class="gallery-card" data-shape="1">
                    <h3>–ü–∞—Ä–∞–ª–ª–µ–ª–µ–ø–∏–ø–µ–¥</h3>
                    <div class="card-image">
                        <img src="pict/par.png" alt="–ü–∞—Ä–∞–ª–ª–µ–ª–µ–ø–∏–ø–µ–¥" class="shape-image">
                    </div>
                </div>
                
                <!-- –§–∏–≥—É—Ä–∞ 2: –¶–∏–ª–∏–Ω–¥—Ä -->
                <div class="gallery-card" data-shape="2">
                    <h3>–¶–∏–ª–∏–Ω–¥—Ä</h3>
                    <div class="card-image">
                        <img src="pict/cyl.png" alt="–¶–∏–ª–∏–Ω–¥—Ä" class="shape-image">
                    </div>
                </div>
                
                <!-- –§–∏–≥—É—Ä–∞ 3: –ü–∏—Ä–∞–º–∏–¥–∞ -->
                <div class="gallery-card" data-shape="3">
                    <h3>–ü–∏—Ä–∞–º–∏–¥–∞</h3>
                    <div class="card-image">
                        <img src="pict/pir.png" alt="–ü–∏—Ä–∞–º–∏–¥–∞" class="shape-image">
                    </div>
                </div>

                <!-- –§–∏–≥—É—Ä–∞ 4: –ö–æ–Ω—É—Å -->
                <div class="gallery-card" data-shape="4">
                    <h3>–ö–æ–Ω—É—Å</h3>
                    <div class="card-image">
                        <img src="pict/cons.png" alt="–ö–æ–Ω—É—Å" class="shape-image">
                    </div>
                </div>

                <!-- –§–∏–≥—É—Ä–∞ 5: –°—Ñ–µ—Ä–∞ -->
                <div class="gallery-card" data-shape="5">
                    <h3>–°—Ñ–µ—Ä–∞</h3>
                    <div class="card-image">
                        <img src="pict/sfer.png" alt="–°—Ñ–µ—Ä–∞" class="shape-image">
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- ==================== –ú–û–î–ê–õ–¨–ù–û–ï –û–ö–ù–û 3D –ü–†–û–°–ú–û–¢–†–ê ==================== -->
    <div id="modal-viewer" class="modal-viewer hidden">
        <div class="modal-header">
            <div class="model-info">
                <span id="current-model-name">–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–∏–≥—É—Ä—É</span>
            </div>
            <div class="controls-info">
                <span>üñ±Ô∏è –õ–ö–ú - –≤—Ä–∞—â–µ–Ω–∏–µ | üñ±Ô∏è –ü–ö–ú - –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ | üñ±Ô∏è –ö–æ–ª–µ—Å–æ - –º–∞—Å—à—Ç–∞–±</span>
            </div>
            <button id="close-modal" class="close-modal-btn">‚úï –ó–∞–∫—Ä—ã—Ç—å</button>
        </div>
        <div id="modal-viewer-content" class="modal-viewer-content"></div>
        
        <!-- –ü–∞–Ω–µ–ª—å —ç–ª–µ–º–µ–Ω—Ç–æ–≤ —Ñ–∏–≥—É—Ä—ã -->
        <div id="elements-panel" class="elements-panel hidden">
            <h3>–≠–ª–µ–º–µ–Ω—Ç—ã —Ñ–∏–≥—É—Ä—ã</h3>
            <div id="elements-content" class="elements-content">
                <!-- –ö–æ–Ω—Ç–µ–Ω—Ç –±—É–¥–µ—Ç –≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å—Å—è –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ -->
            </div>
        </div>

        <div id="loading-indicator" class="loading-indicator hidden">
            <div class="loading-spinner"></div>
            <p>–ó–∞–≥—Ä—É–∑–∫–∞ –º–æ–¥–µ–ª–∏...</p>
        </div>
    </div>

    <footer class="footer">
        <div class="container">
            <p>&copy; 2025 3D Geometry Project</p>
        </div>
    </footer>

    <script>
        // ==================== –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø 3D –§–ò–ì–£–† ====================
        const shapesConfig = {
            '0': { name: '–ö—É–±', type: 'cube' },
            '1': { name: '–ü–∞—Ä–∞–ª–ª–µ–ª–µ–ø–∏–ø–µ–¥', type: 'parallelepiped' },
            '2': { name: '–¶–∏–ª–∏–Ω–¥—Ä', type: 'cylinder' },
            '3': { name: '–ü–∏—Ä–∞–º–∏–¥–∞', type: 'pyramid' },
            '4': { name: '–ö–æ–Ω—É—Å', type: 'cone' },
            '5': { name: '–°—Ñ–µ—Ä–∞', type: 'sphere' }
        };

        // ==================== –ù–ê–°–¢–†–û–ö–ò –¶–í–ï–¢–û–í –ò –ü–†–û–ó–†–ê–ß–ù–û–°–¢–ò ====================
        const shapeColors = {
            '–ö—É–±': 0x3498db,          // –°–∏–Ω–∏–π
            '–ü–∞—Ä–∞–ª–ª–µ–ª–µ–ø–∏–ø–µ–¥': 0xe74c3c, // –ö—Ä–∞—Å–Ω—ã–π
            '–¶–∏–ª–∏–Ω–¥—Ä': 0x2ecc71,       // –ó–µ–ª–µ–Ω—ã–π
            '–ü–∏—Ä–∞–º–∏–¥–∞': 0x9b59b6,      // –§–∏–æ–ª–µ—Ç–æ–≤—ã–π
            '–ö–æ–Ω—É—Å': 0xf39c12,         // –û—Ä–∞–Ω–∂–µ–≤—ã–π
            '–°—Ñ–µ—Ä–∞': 0x1abc9c          // –ë–∏—Ä—é–∑–æ–≤—ã–π
        };
        
        const highlightColors = {
            '–ö—É–±': 0xFFD700,          // –ó–æ–ª–æ—Ç–æ–π
            '–ü–∞—Ä–∞–ª–ª–µ–ª–µ–ø–∏–ø–µ–¥': 0x00FFFF, // –ì–æ–ª—É–±–æ–π
            '–¶–∏–ª–∏–Ω–¥—Ä': 0xFF00FF,       // –ü—É—Ä–ø—É—Ä–Ω—ã–π
            '–ü–∏—Ä–∞–º–∏–¥–∞': 0x00FF00,      // –Ø—Ä–∫–æ-–∑–µ–ª–µ–Ω—ã–π
            '–ö–æ–Ω—É—Å': 0x0000FF,         // –°–∏–Ω–∏–π
            '–°—Ñ–µ—Ä–∞': 0xFF4500          // –û—Ä–∞–Ω–∂–µ–≤–æ-–∫—Ä–∞—Å–Ω—ã–π
        };
        
        const shapeOpacity = 0.7;
        const HIGHLIGHT_DURATION = 5000;
        const VERTEX_HIGHLIGHT_SCALE = 1.8;
        const EDGE_HIGHLIGHT_WIDTH = 8;
        const EDGE_HIGHLIGHT_SCALE = 2; // –£–≤–µ–ª–∏—á–µ–Ω–∏–µ —Ä–µ–±—Ä–∞ –≤ 2 —Ä–∞–∑–∞
        const FACE_HIGHLIGHT_OPACITY = 0.9;
        
        const CAMERA_LIMITS = {
            minDistance: 2,
            maxDistance: 50,
            minZoom: 0.5,
            maxZoom: 10
        };

        // ==================== –ü–ï–†–ï–ú–ï–ù–ù–´–ï –ò –≠–õ–ï–ú–ï–ù–¢–´ DOM ====================
        const modalViewer = document.getElementById('modal-viewer');
        const modalViewerContent = document.getElementById('modal-viewer-content');
        const closeModalBtn = document.getElementById('close-modal');
        const galleryCards = document.querySelectorAll('.gallery-card');
        const elementsPanel = document.getElementById('elements-panel');
        const elementsContent = document.getElementById('elements-content');

        // Three.js –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        let scene, camera, renderer, controls, currentMesh;
        let vertexObjects = new Map();
        let edgeObjects = new Map();
        let faceObjects = new Map();
        let vertexLabels = [];
        let currentHighlightedElement = null;
        let highlightTimeouts = [];
        let currentShapeName = '';

        // ==================== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø 3D –°–¶–ï–ù–´ ====================
        function init3DViewer() {
            if (scene) return;

            try {
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0xf0f0f0);

                camera = new THREE.PerspectiveCamera(75, modalViewerContent.clientWidth / modalViewerContent.clientHeight, 0.1, 1000);
                camera.position.z = 5;

                renderer = new THREE.WebGLRenderer({ 
                    antialias: true,
                    alpha: false,
                    powerPreference: "high-performance"
                });
                renderer.setSize(modalViewerContent.clientWidth, modalViewerContent.clientHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                modalViewerContent.innerHTML = '';
                modalViewerContent.appendChild(renderer.domElement);

                const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
                scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
                directionalLight.position.set(10, 10, 10);
                scene.add(directionalLight);

                const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
                fillLight.position.set(-10, 5, -10);
                scene.add(fillLight);

                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.minDistance = CAMERA_LIMITS.minDistance;
                controls.maxDistance = CAMERA_LIMITS.maxDistance;
                controls.minZoom = CAMERA_LIMITS.minZoom;
                controls.maxZoom = CAMERA_LIMITS.maxZoom;
                controls.enablePan = true;
                controls.screenSpacePanning = true;

                function animate() {
                    requestAnimationFrame(animate);
                    controls.update();
                    updateLabels();
                    renderer.render(scene, camera);
                }
                animate();

                window.addEventListener('resize', onWindowResize);

            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ 3D –ø—Ä–æ—Å–º–æ—Ç—Ä—â–∏–∫–∞:', error);
                modalViewerContent.innerHTML = '<div class="error-message">–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ 3D –ø—Ä–æ—Å–º–æ—Ç—Ä—â–∏–∫–∞</div>';
            }
        }

        // ==================== –û–°–ù–û–í–ù–´–ï –§–£–ù–ö–¶–ò–ò –£–ü–†–ê–í–õ–ï–ù–ò–Ø ====================
        function createShape(shapeId) {
            if (!scene) return;
            cleanupCurrentShape();

            const config = shapesConfig[shapeId];
            if (!config) return;

            currentShapeName = config.name;
            createGeometryShape(config);
            elementsPanel.classList.remove('hidden');
        }

        function cleanupCurrentShape() {
            if (currentMesh) {
                scene.remove(currentMesh);
                cleanupMesh(currentMesh);
                currentMesh = null;
            }

            // –£–¥–∞–ª—è–µ–º –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä—ã —Ä–µ–±–µ—Ä
            edgeObjects.forEach(obj => {
                scene.remove(obj);
                if (obj.userData.child && obj.userData.child.geometry) {
                    obj.userData.child.geometry.dispose();
                    obj.userData.child.material.dispose();
                }
            });
            
            vertexObjects.forEach(obj => scene.remove(obj));
            faceObjects.forEach(obj => scene.remove(obj));
            
            edgeObjects.clear();
            vertexObjects.clear();
            faceObjects.clear();

            vertexLabels.forEach(label => label.element.remove());
            vertexLabels = [];

            clearAllTimeouts();
            currentHighlightedElement = null;
        }

        function clearAllTimeouts() {
            highlightTimeouts.forEach(timeout => clearTimeout(timeout));
            highlightTimeouts = [];
        }

        // ==================== –°–û–ó–î–ê–ù–ò–ï –§–ò–ì–£–† ====================
        function createGeometryShape(config) {
            console.log(`–°–æ–∑–¥–∞–Ω–∏–µ —Ñ–∏–≥—É—Ä—ã: ${config.name}`);
            
            try {
                const color = shapeColors[config.name] || 0x3498db;
                const baseMaterial = new THREE.MeshPhongMaterial({ 
                    color: color,
                    shininess: 60,
                    specular: 0x222222,
                    transparent: true,
                    opacity: shapeOpacity,
                    side: THREE.DoubleSide
                });

                switch (config.type) {
                    case 'cube':
                        currentMesh = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 2), baseMaterial);
                        createCubeElements();
                        break;
                    case 'parallelepiped':
                        currentMesh = new THREE.Mesh(new THREE.BoxGeometry(3, 2, 1.5), baseMaterial);
                        createParallelepipedElements();
                        break;
                    case 'cylinder':
                        currentMesh = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 3, 32), baseMaterial);
                        createCylinderElements();
                        break;
                    case 'pyramid':
                        // –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–∞–≤–∏–ª—å–Ω—É—é —á–µ—Ç—ã—Ä–µ—Ö—É–≥–æ–ª—å–Ω—É—é –ø–∏—Ä–∞–º–∏–¥—É
                        currentMesh = createFourSidedPyramid(color, shapeOpacity);
                        createPyramidElements();
                        break;
                    case 'cone':
                        currentMesh = new THREE.Mesh(new THREE.ConeGeometry(1.2, 3, 32), baseMaterial);
                        createConeElements();
                        break;
                    case 'sphere':
                        currentMesh = new THREE.Mesh(new THREE.SphereGeometry(1.5, 32, 32), baseMaterial);
                        createSphereElements();
                        break;
                    default:
                        currentMesh = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 2), baseMaterial);
                        createCubeElements();
                }

                if (currentMesh) {
                    scene.add(currentMesh);
                }
                centerCameraOnObject(currentMesh);
                updateModelName(config.name);

            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Ñ–∏–≥—É—Ä—ã:', error);
            }
        }

        // ==================== –§–£–ù–ö–¶–ò–Ø –°–û–ó–î–ê–ù–ò–Ø –ß–ï–¢–´–†–ï–•–£–ì–û–õ–¨–ù–û–ô –ü–ò–†–ê–ú–ò–î–´ ====================
        function createFourSidedPyramid(color, opacity) {
            // –°–æ–∑–¥–∞–µ–º –ø—Ä–∞–≤–∏–ª—å–Ω—É—é —á–µ—Ç—ã—Ä–µ—Ö—É–≥–æ–ª—å–Ω—É—é –ø–∏—Ä–∞–º–∏–¥—É
            const baseMaterial = new THREE.MeshPhongMaterial({ 
                color: color,
                shininess: 60,
                specular: 0x222222,
                transparent: true,
                opacity: opacity,
                side: THREE.DoubleSide
            });

            // –í–µ—Ä—à–∏–Ω—ã —á–µ—Ç—ã—Ä–µ—Ö—É–≥–æ–ª—å–Ω–æ–π –ø–∏—Ä–∞–º–∏–¥—ã:
            // –û—Å–Ω–æ–≤–∞–Ω–∏–µ - –∫–≤–∞–¥—Ä–∞—Ç
            // –í–µ—Ä—à–∏–Ω–∞ S –Ω–∞–¥ —Ü–µ–Ω—Ç—Ä–æ–º –æ—Å–Ω–æ–≤–∞–Ω–∏—è
            const baseSize = 1.5; // –†–∞–∑–º–µ—Ä –æ—Å–Ω–æ–≤–∞–Ω–∏—è
            const height = 2.5;   // –í—ã—Å–æ—Ç–∞ –ø–∏—Ä–∞–º–∏–¥—ã
            
            // –í–µ—Ä—à–∏–Ω—ã –æ—Å–Ω–æ–≤–∞–Ω–∏—è
            const vertices = [
                // –û—Å–Ω–æ–≤–∞–Ω–∏–µ
                new THREE.Vector3(-baseSize, 0, -baseSize), // A: –∑–∞–¥–Ω–∏–π –ª–µ–≤—ã–π
                new THREE.Vector3(baseSize, 0, -baseSize),  // B: –∑–∞–¥–Ω–∏–π –ø—Ä–∞–≤—ã–π
                new THREE.Vector3(baseSize, 0, baseSize),   // C: –ø–µ—Ä–µ–¥–Ω–∏–π –ø—Ä–∞–≤—ã–π
                new THREE.Vector3(-baseSize, 0, baseSize),  // D: –ø–µ—Ä–µ–¥–Ω–∏–π –ª–µ–≤—ã–π
                // –í–µ—Ä—à–∏–Ω–∞
                new THREE.Vector3(0, height, 0)             // S: –≤–µ—Ä—à–∏–Ω–∞
            ];

            // –ò–Ω–¥–µ–∫—Å—ã –¥–ª—è —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–æ–≤ (5 –≥—Ä–∞–Ω–µ–π: 4 –±–æ–∫–æ–≤—ã—Ö + –æ—Å–Ω–æ–≤–∞–Ω–∏–µ)
            const indices = [
                // –û—Å–Ω–æ–≤–∞–Ω–∏–µ (–¥–≤–∞ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞)
                0, 1, 2, // —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫ A-B-C
                0, 2, 3, // —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫ A-C-D
                
                // –ë–æ–∫–æ–≤—ã–µ –≥—Ä–∞–Ω–∏
                0, 1, 4, // –≥—Ä–∞–Ω—å A-B-S
                1, 2, 4, // –≥—Ä–∞–Ω—å B-C-S
                2, 3, 4, // –≥—Ä–∞–Ω—å C-D-S
                3, 0, 4  // –≥—Ä–∞–Ω—å D-A-S
            ];

            // –°–æ–∑–¥–∞–µ–º –≥–µ–æ–º–µ—Ç—Ä–∏—é
            const geometry = new THREE.BufferGeometry();
            
            // –°–æ–∑–¥–∞–µ–º –º–∞—Å—Å–∏–≤ –≤–µ—Ä—à–∏–Ω
            const positions = [];
            vertices.forEach(vertex => {
                positions.push(vertex.x, vertex.y, vertex.z);
            });
            
            // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∞—Ç—Ä–∏–±—É—Ç—ã
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setIndex(indices);
            
            // –í—ã—á–∏—Å–ª—è–µ–º –Ω–æ—Ä–º–∞–ª–∏ –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ –æ—Å–≤–µ—â–µ–Ω–∏—è
            geometry.computeVertexNormals();
            
            return new THREE.Mesh(geometry, baseMaterial);
        }

        // ==================== –°–û–ó–î–ê–ù–ò–ï –≠–õ–ï–ú–ï–ù–¢–û–í ====================
        function createCubeElements() {
            const vertices = {
                'A': [1, -1, 1], 'B': [1, -1, -1], 'C': [-1, -1, -1], 'D': [-1, -1, 1],
                'E': [1, 1, 1], 'F': [1, 1, -1], 'G': [-1, 1, -1], 'H': [-1, 1, 1]
            };
            createVertices(vertices);
            createEdges([
                ['A', 'B'], ['B', 'C'], ['C', 'D'], ['D', 'A'],
                ['E', 'F'], ['F', 'G'], ['G', 'H'], ['H', 'E'],
                ['A', 'E'], ['B', 'F'], ['C', 'G'], ['D', 'H']
            ], vertices);
            createCubeFaces();
            createVertexLabels(vertices);
            generateElementsPanel('cube');
        }

        function createParallelepipedElements() {
            const vertices = {
                'A': [1.5, -1, 0.75], 'B': [1.5, -1, -0.75], 'C': [-1.5, -1, -0.75], 'D': [-1.5, -1, 0.75],
                'E': [1.5, 1, 0.75], 'F': [1.5, 1, -0.75], 'G': [-1.5, 1, -0.75], 'H': [-1.5, 1, 0.75]
            };
            createVertices(vertices);
            createEdges([
                ['A', 'B'], ['B', 'C'], ['C', 'D'], ['D', 'A'],
                ['E', 'F'], ['F', 'G'], ['G', 'H'], ['H', 'E'],
                ['A', 'E'], ['B', 'F'], ['C', 'G'], ['D', 'H']
            ], vertices);
            createParallelepipedFaces();
            createVertexLabels(vertices);
            generateElementsPanel('parallelepiped');
        }

        function createCylinderElements() {
            const vertices = {
                'O1': [0, -1.5, 0], 'O2': [0, 1.5, 0],
                'A': [1, -1.5, 0], 'B': [1, 1.5, 0],
                'C': [-1, -1.5, 0], 'D': [-1, 1.5, 0]
            };
            createVertices(vertices);
            createEdges([
                ['O1', 'O2'], ['O1', 'A'], ['O2', 'B'],
                ['O1', 'C'], ['O2', 'D']
            ], vertices);
            createCylinderFaces();
            createVertexLabels(vertices);
            generateElementsPanel('cylinder');
        }

        function createPyramidElements() {
            // –í–µ—Ä—à–∏–Ω—ã –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π —á–µ—Ç—ã—Ä–µ—Ö—É–≥–æ–ª—å–Ω–æ–π –ø–∏—Ä–∞–º–∏–¥—ã
            const baseSize = 1.5;
            const height = 2.5;
            
            const vertices = {
                'A': [-baseSize, 0, -baseSize], // –ó–∞–¥–Ω–∏–π –ª–µ–≤—ã–π
                'B': [baseSize, 0, -baseSize],  // –ó–∞–¥–Ω–∏–π –ø—Ä–∞–≤—ã–π
                'C': [baseSize, 0, baseSize],   // –ü–µ—Ä–µ–¥–Ω–∏–π –ø—Ä–∞–≤—ã–π
                'D': [-baseSize, 0, baseSize],  // –ü–µ—Ä–µ–¥–Ω–∏–π –ª–µ–≤—ã–π
                'S': [0, height, 0]             // –í–µ—Ä—à–∏–Ω–∞
            };
            
            createVertices(vertices);
            createEdges([
                // –†–µ–±—Ä–∞ –æ—Å–Ω–æ–≤–∞–Ω–∏—è
                ['A', 'B'], ['B', 'C'], ['C', 'D'], ['D', 'A'],
                // –ë–æ–∫–æ–≤—ã–µ —Ä–µ–±—Ä–∞
                ['A', 'S'], ['B', 'S'], ['C', 'S'], ['D', 'S']
            ], vertices);
            createPyramidFaces(vertices);
            createVertexLabels(vertices);
            generateElementsPanel('pyramid');
        }

        function createConeElements() {
            const vertices = {
                'O': [0, -1.5, 0], 'S': [0, 1.5, 0],
                'A': [1.2, -1.5, 0], 'B': [-1.2, -1.5, 0]
            };
            createVertices(vertices);
            createEdges([
                ['O', 'S'], ['O', 'A'], ['O', 'B'],
                ['A', 'S'], ['B', 'S']
            ], vertices);
            createConeFaces();
            createVertexLabels(vertices);
            generateElementsPanel('cone');
        }

        function createSphereElements() {
            const vertices = {
                'O': [0, 0, 0], 'N': [0, 1.5, 0], 'S': [0, -1.5, 0], 'E': [1.5, 0, 0]
            };
            createVertices(vertices);
            createEdges([['N', 'S'], ['O', 'E']], vertices);
            createSphereFaces();
            createVertexLabels(vertices);
            generateElementsPanel('sphere');
        }

        // ==================== –°–û–ó–î–ê–ù–ò–ï –ö–û–ú–ü–û–ù–ï–ù–¢–û–í ====================
        function createVertices(vertices) {
            const vertexGeometry = new THREE.SphereGeometry(0.08, 12, 12);
            const vertexMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000, shininess: 100 });

            Object.entries(vertices).forEach(([label, pos]) => {
                const sphere = new THREE.Mesh(vertexGeometry, vertexMaterial);
                sphere.position.set(...pos);
                sphere.userData = { 
                    type: 'vertex', 
                    label, 
                    originalColor: 0xff0000, 
                    originalScale: new THREE.Vector3(1, 1, 1) 
                };
                scene.add(sphere);
                vertexObjects.set(label, sphere);
            });
        }

        function createEdges(edgePairs, vertices) {
            edgePairs.forEach(pair => {
                const edgeId = pair.join('');
                const points = [
                    new THREE.Vector3(...vertices[pair[0]]),
                    new THREE.Vector3(...vertices[pair[1]])
                ];
                
                // –°–æ–∑–¥–∞–µ–º –≥–µ–æ–º–µ—Ç—Ä–∏—é —Ä–µ–±—Ä–∞
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ 
                    color: 0x000000, 
                    linewidth: 2 
                });
                const edge = new THREE.Line(geometry, material);
                
                // –°–æ–∑–¥–∞–µ–º –Ω–µ–≤–∏–¥–∏–º—ã–π –æ–±—ä–µ–∫—Ç-–∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—è
                const edgeContainer = new THREE.Group();
                edgeContainer.add(edge);
                
                // –í—ã—á–∏—Å–ª—è–µ–º —Ü–µ–Ω—Ç—Ä —Ä–µ–±—Ä–∞ –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
                const center = new THREE.Vector3()
                    .add(points[0])
                    .add(points[1])
                    .multiplyScalar(0.5);
                edgeContainer.position.copy(center);
                
                // –í—ã—á–∏—Å–ª—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—è
                const direction = new THREE.Vector3()
                    .subVectors(points[1], points[0])
                    .normalize();
                
                // –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è –≤—ã–¥–µ–ª–µ–Ω–∏—è
                edgeContainer.userData = { 
                    type: 'edge', 
                    id: edgeId, 
                    points: points,
                    direction: direction,
                    length: points[0].distanceTo(points[1]),
                    originalColor: 0x000000, 
                    originalLinewidth: 2,
                    child: edge // —Å–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Å—ã–ª–∫—É –Ω–∞ –ª–∏–Ω–∏—é
                };
                
                // –†–∞–∑–º–µ—â–∞–µ–º –ª–∏–Ω–∏—é –≤–Ω—É—Ç—Ä–∏ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
                edge.position.sub(center);
                
                scene.add(edgeContainer);
                edgeObjects.set(edgeId, edgeContainer);
            });
        }

        function createCubeFaces() {
            const faceMaterial = new THREE.MeshPhongMaterial({ 
                color: shapeColors['–ö—É–±'], 
                transparent: true, 
                opacity: shapeOpacity * 0.7,
                side: THREE.DoubleSide
            });

            const faceConfigs = [
                { position: [0, -1, 0], rotation: [Math.PI / 2, 0, 0], id: 'bottom', name: '–û—Å–Ω–æ–≤–∞–Ω–∏–µ' },
                { position: [0, 1, 0], rotation: [-Math.PI / 2, 0, 0], id: 'top', name: '–í–µ—Ä—Ö–Ω—è—è –≥—Ä–∞–Ω—å' },
                { position: [0, 0, 1], rotation: [0, 0, 0], id: 'front', name: '–ü–µ—Ä–µ–¥–Ω—è—è –≥—Ä–∞–Ω—å' },
                { position: [1, 0, 0], rotation: [0, Math.PI / 2, 0], id: 'right', name: '–ü—Ä–∞–≤–∞—è –≥—Ä–∞–Ω—å' },
                { position: [0, 0, -1], rotation: [0, Math.PI, 0], id: 'back', name: '–ó–∞–¥–Ω—è—è –≥—Ä–∞–Ω—å' },
                { position: [-1, 0, 0], rotation: [0, -Math.PI / 2, 0], id: 'left', name: '–õ–µ–≤–∞—è –≥—Ä–∞–Ω—å' }
            ];
            
            faceConfigs.forEach(config => {
                const face = createPlaneFace(2, 2, config.position, config.rotation, faceMaterial);
                face.userData = { 
                    type: 'face', 
                    id: config.id, 
                    name: config.name, 
                    originalColor: shapeColors['–ö—É–±'], 
                    originalOpacity: shapeOpacity * 0.7,
                    originalScale: new THREE.Vector3(1, 1, 1),
                    originalPosition: new THREE.Vector3(...config.position)
                };
                scene.add(face);
                faceObjects.set(config.id, face);
            });
        }

        function createParallelepipedFaces() {
            const faceMaterial = new THREE.MeshPhongMaterial({ 
                color: shapeColors['–ü–∞—Ä–∞–ª–ª–µ–ª–µ–ø–∏–ø–µ–¥'], 
                transparent: true, 
                opacity: shapeOpacity * 0.7,
                side: THREE.DoubleSide
            });

            const faceConfigs = [
                { position: [0, -1, 0], rotation: [Math.PI / 2, 0, 0], id: 'bottom', name: '–ù–∏–∂–Ω–µ–µ –æ—Å–Ω–æ–≤–∞–Ω–∏–µ', size: [3, 1.5] },
                { position: [0, 1, 0], rotation: [-Math.PI / 2, 0, 0], id: 'top', name: '–í–µ—Ä—Ö–Ω–µ–µ –æ—Å–Ω–æ–≤–∞–Ω–∏–µ', size: [3, 1.5] },
                { position: [0, 0, 0.75], rotation: [0, 0, 0], id: 'front', name: '–ü–µ—Ä–µ–¥–Ω—è—è –≥—Ä–∞–Ω—å', size: [3, 2] },
                { position: [0, 0, -0.75], rotation: [0, Math.PI, 0], id: 'back', name: '–ó–∞–¥–Ω—è—è –≥—Ä–∞–Ω—å', size: [3, 2] },
                { position: [1.5, 0, 0], rotation: [0, Math.PI / 2, 0], id: 'right', name: '–ü—Ä–∞–≤–∞—è –≥—Ä–∞–Ω—å', size: [1.5, 2] },
                { position: [-1.5, 0, 0], rotation: [0, -Math.PI / 2, 0], id: 'left', name: '–õ–µ–≤–∞—è –≥—Ä–∞–Ω—å', size: [1.5, 2] }
            ];
            
            faceConfigs.forEach(config => {
                const face = createPlaneFace(config.size[0], config.size[1], config.position, config.rotation, faceMaterial);
                face.userData = { 
                    type: 'face', 
                    id: config.id, 
                    name: config.name, 
                    originalColor: shapeColors['–ü–∞—Ä–∞–ª–ª–µ–ª–µ–ø–∏–ø–µ–¥'], 
                    originalOpacity: shapeOpacity * 0.7,
                    originalScale: new THREE.Vector3(1, 1, 1),
                    originalPosition: new THREE.Vector3(...config.position)
                };
                scene.add(face);
                faceObjects.set(config.id, face);
            });
        }

        function createCylinderFaces() {
            const baseMaterial = new THREE.MeshPhongMaterial({ 
                color: shapeColors['–¶–∏–ª–∏–Ω–¥—Ä'], 
                transparent: true, 
                opacity: shapeOpacity * 0.7,
                side: THREE.DoubleSide
            });

            // –ù–∏–∂–Ω–µ–µ –æ—Å–Ω–æ–≤–∞–Ω–∏–µ
            const bottomBase = new THREE.Mesh(new THREE.CircleGeometry(1, 32), baseMaterial);
            bottomBase.position.set(0, -1.5, 0);
            bottomBase.rotation.x = -Math.PI / 2;
            bottomBase.userData = { 
                type: 'face', 
                id: 'base1', 
                name: '–ù–∏–∂–Ω–µ–µ –æ—Å–Ω–æ–≤–∞–Ω–∏–µ', 
                originalColor: shapeColors['–¶–∏–ª–∏–Ω–¥—Ä'], 
                originalOpacity: shapeOpacity * 0.7,
                originalScale: new THREE.Vector3(1, 1, 1)
            };
            scene.add(bottomBase);
            faceObjects.set('base1', bottomBase);

            // –í–µ—Ä—Ö–Ω–µ–µ –æ—Å–Ω–æ–≤–∞–Ω–∏–µ
            const topBase = new THREE.Mesh(new THREE.CircleGeometry(1, 32), baseMaterial);
            topBase.position.set(0, 1.5, 0);
            topBase.rotation.x = Math.PI / 2;
            topBase.userData = { 
                type: 'face', 
                id: 'base2', 
                name: '–í–µ—Ä—Ö–Ω–µ–µ –æ—Å–Ω–æ–≤–∞–Ω–∏–µ', 
                originalColor: shapeColors['–¶–∏–ª–∏–Ω–¥—Ä'], 
                originalOpacity: shapeOpacity * 0.7,
                originalScale: new THREE.Vector3(1, 1, 1)
            };
            scene.add(topBase);
            faceObjects.set('base2', topBase);

            // –ë–æ–∫–æ–≤–∞—è –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç—å
            const sideMaterial = new THREE.MeshPhongMaterial({ 
                color: shapeColors['–¶–∏–ª–∏–Ω–¥—Ä'], 
                transparent: true, 
                opacity: shapeOpacity * 0.8,
                side: THREE.DoubleSide
            });
            const sideGeometry = new THREE.CylinderGeometry(1, 1, 3, 32, 1, true);
            const sideFace = new THREE.Mesh(sideGeometry, sideMaterial);
            sideFace.userData = { 
                type: 'face', 
                id: 'side', 
                name: '–ë–æ–∫–æ–≤–∞—è –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç—å', 
                originalColor: shapeColors['–¶–∏–ª–∏–Ω–¥—Ä'], 
                originalOpacity: shapeOpacity * 0.8,
                originalScale: new THREE.Vector3(1, 1, 1)
            };
            scene.add(sideFace);
            faceObjects.set('side', sideFace);
        }

        function createPyramidFaces(vertices) {
            const faceMaterial = new THREE.MeshPhongMaterial({ 
                color: shapeColors['–ü–∏—Ä–∞–º–∏–¥–∞'], 
                transparent: true, 
                opacity: shapeOpacity * 0.7,
                side: THREE.DoubleSide
            });

            // –ë–æ–∫–æ–≤—ã–µ –≥—Ä–∞–Ω–∏ (—Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∏)
            const sideFaces = [
                { vertices: ['A', 'B', 'S'], id: 'side1', name: '–ì—Ä–∞–Ω—å ABS' },
                { vertices: ['B', 'C', 'S'], id: 'side2', name: '–ì—Ä–∞–Ω—å BCS' },
                { vertices: ['C', 'D', 'S'], id: 'side3', name: '–ì—Ä–∞–Ω—å CDS' },
                { vertices: ['D', 'A', 'S'], id: 'side4', name: '–ì—Ä–∞–Ω—å DAS' }
            ];

            sideFaces.forEach(faceConfig => {
                const points = [
                    new THREE.Vector3(...vertices[faceConfig.vertices[0]]),
                    new THREE.Vector3(...vertices[faceConfig.vertices[1]]),
                    new THREE.Vector3(...vertices[faceConfig.vertices[2]])
                ];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                geometry.computeVertexNormals();
                const face = new THREE.Mesh(geometry, faceMaterial);
                face.userData = { 
                    type: 'face', 
                    id: faceConfig.id, 
                    name: faceConfig.name, 
                    originalColor: shapeColors['–ü–∏—Ä–∞–º–∏–¥–∞'], 
                    originalOpacity: shapeOpacity * 0.7,
                    originalScale: new THREE.Vector3(1, 1, 1)
                };
                scene.add(face);
                faceObjects.set(faceConfig.id, face);
            });

            // –û—Å–Ω–æ–≤–∞–Ω–∏–µ (–∫–≤–∞–¥—Ä–∞—Ç –∏–∑ –¥–≤—É—Ö —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–æ–≤)
            const basePoints = [
                new THREE.Vector3(...vertices['A']),
                new THREE.Vector3(...vertices['B']),
                new THREE.Vector3(...vertices['C']),
                new THREE.Vector3(...vertices['D'])
            ];
            const baseGeometry = new THREE.BufferGeometry().setFromPoints(basePoints);
            baseGeometry.setIndex([0, 1, 2, 0, 2, 3]);
            baseGeometry.computeVertexNormals();
            const baseFace = new THREE.Mesh(baseGeometry, faceMaterial);
            baseFace.userData = { 
                type: 'face', 
                id: 'base', 
                name: '–û—Å–Ω–æ–≤–∞–Ω–∏–µ', 
                originalColor: shapeColors['–ü–∏—Ä–∞–º–∏–¥–∞'], 
                originalOpacity: shapeOpacity * 0.7,
                originalScale: new THREE.Vector3(1, 1, 1)
            };
            scene.add(baseFace);
            faceObjects.set('base', baseFace);
        }

        function createConeFaces() {
            const baseMaterial = new THREE.MeshPhongMaterial({ 
                color: shapeColors['–ö–æ–Ω—É—Å'], 
                transparent: true, 
                opacity: shapeOpacity * 0.7,
                side: THREE.DoubleSide
            });

            // –û—Å–Ω–æ–≤–∞–Ω–∏–µ
            const base = new THREE.Mesh(new THREE.CircleGeometry(1.2, 32), baseMaterial);
            base.position.set(0, -1.5, 0);
            base.rotation.x = -Math.PI / 2;
            base.userData = { 
                type: 'face', 
                id: 'base', 
                name: '–û—Å–Ω–æ–≤–∞–Ω–∏–µ', 
                originalColor: shapeColors['–ö–æ–Ω—É—Å'], 
                originalOpacity: shapeOpacity * 0.7,
                originalScale: new THREE.Vector3(1, 1, 1)
            };
            scene.add(base);
            faceObjects.set('base', base);

            // –ë–æ–∫–æ–≤–∞—è –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç—å
            const sideMaterial = new THREE.MeshPhongMaterial({ 
                color: shapeColors['–ö–æ–Ω—É—Å'], 
                transparent: true, 
                opacity: shapeOpacity * 0.8,
                side: THREE.DoubleSide
            });
            const sideGeometry = new THREE.ConeGeometry(1.2, 3, 32, 1, true);
            const sideFace = new THREE.Mesh(sideGeometry, sideMaterial);
            sideFace.userData = { 
                type: 'face', 
                id: 'side', 
                name: '–ë–æ–∫–æ–≤–∞—è –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç—å', 
                originalColor: shapeColors['–ö–æ–Ω—É—Å'], 
                originalOpacity: shapeOpacity * 0.8,
                originalScale: new THREE.Vector3(1, 1, 1)
            };
            scene.add(sideFace);
            faceObjects.set('side', sideFace);
        }

        function createSphereFaces() {
            const sphereMaterial = new THREE.MeshPhongMaterial({ 
                color: shapeColors['–°—Ñ–µ—Ä–∞'], 
                transparent: true, 
                opacity: shapeOpacity * 0.3,
                side: THREE.DoubleSide
            });

            const sphereFace = new THREE.Mesh(new THREE.SphereGeometry(1.5, 32, 32), sphereMaterial);
            sphereFace.userData = { 
                type: 'face', 
                id: 'surface', 
                name: '–ü–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç—å —Å—Ñ–µ—Ä—ã', 
                originalColor: shapeColors['–°—Ñ–µ—Ä–∞'], 
                originalOpacity: shapeOpacity * 0.3,
                originalScale: new THREE.Vector3(1, 1, 1)
            };
            scene.add(sphereFace);
            faceObjects.set('surface', sphereFace);
        }

        function createPlaneFace(width, height, position, rotation, material) {
            const geometry = new THREE.PlaneGeometry(width, height);
            const face = new THREE.Mesh(geometry, material);
            face.position.set(...position);
            face.rotation.set(...rotation);
            return face;
        }

        function createVertexLabels(vertices) {
            Object.entries(vertices).forEach(([label, pos]) => {
                const labelPos = new THREE.Vector3(...pos).multiplyScalar(1.2);
                const labelElement = document.createElement('div');
                labelElement.className = 'label';
                labelElement.textContent = label;
                labelElement.style.display = 'none';
                modalViewerContent.appendChild(labelElement);
                
                vertexLabels.push({ element: labelElement, position: labelPos, label });
            });
        }

        // ==================== –ü–ê–ù–ï–õ–¨ –≠–õ–ï–ú–ï–ù–¢–û–í ====================
        function generateElementsPanel(shapeType) {
            const panels = {
                'cube': `
                    <div class="element-section">
                        <h4>–í–µ—Ä—à–∏–Ω—ã (8):</h4>
                        <div class="element-list">
                            <span class="element-item" data-type="vertex" data-id="A">A</span>
                            <span class="element-item" data-type="vertex" data-id="B">B</span>
                            <span class="element-item" data-type="vertex" data-id="C">C</span>
                            <span class="element-item" data-type="vertex" data-id="D">D</span>
                            <span class="element-item" data-type="vertex" data-id="E">E</span>
                            <span class="element-item" data-type="vertex" data-id="F">F</span>
                            <span class="element-item" data-type="vertex" data-id="G">G</span>
                            <span class="element-item" data-type="vertex" data-id="H">H</span>
                        </div>
                    </div>
                    <div class="element-section">
                        <h4>–†–µ–±—Ä–∞ (12):</h4>
                        <div class="element-list">
                            <span class="element-item" data-type="edge" data-id="AB">AB</span>
                            <span class="element-item" data-type="edge" data-id="BC">BC</span>
                            <span class="element-item" data-type="edge" data-id="CD">CD</span>
                            <span class="element-item" data-type="edge" data-id="DA">DA</span>
                            <span class="element-item" data-type="edge" data-id="EF">EF</span>
                            <span class="element-item" data-type="edge" data-id="FG">FG</span>
                            <span class="element-item" data-type="edge" data-id="GH">GH</span>
                            <span class="element-item" data-type="edge" data-id="HE">HE</span>
                            <span class="element-item" data-type="edge" data-id="AE">AE</span>
                            <span class="element-item" data-type="edge" data-id="BF">BF</span>
                            <span class="element-item" data-type="edge" data-id="CG">CG</span>
                            <span class="element-item" data-type="edge" data-id="DH">DH</span>
                        </div>
                    </div>
                    <div class="element-section">
                        <h4>–ì—Ä–∞–Ω–∏ (6):</h4>
                        <div class="element-list">
                            <span class="element-item" data-type="face" data-id="bottom">ABCD</span>
                            <span class="element-item" data-type="face" data-id="top">FEHG</span>
                            <span class="element-item" data-type="face" data-id="front">EADH</span><br>
                            <span class="element-item" data-type="face" data-id="right">FBAE</span>
                            <span class="element-item" data-type="face" data-id="back">GCBF</span>
                            <span class="element-item" data-type="face" data-id="left">HDCG</span>
                        </div>
                    </div>
                `,
                'parallelepiped': `
                    <div class="element-section">
                        <h4>–í–µ—Ä—à–∏–Ω—ã (8):</h4>
                        <div class="element-list">
                            <span class="element-item" data-type="vertex" data-id="A">A</span>
                            <span class="element-item" data-type="vertex" data-id="B">B</span>
                            <span class="element-item" data-type="vertex" data-id="C">C</span>
                            <span class="element-item" data-type="vertex" data-id="D">D</span>
                            <span class="element-item" data-type="vertex" data-id="E">E</span>
                            <span class="element-item" data-type="vertex" data-id="F">F</span>
                            <span class="element-item" data-type="vertex" data-id="G">G</span>
                            <span class="element-item" data-type="vertex" data-id="H">H</span>
                        </div>
                    </div>
                    <div class="element-section">
                        <h4>–†–µ–±—Ä–∞ (12):</h4>
                        <div class="element-list">
                            <span class="element-item" data-type="edge" data-id="AB">AB</span>
                            <span class="element-item" data-type="edge" data-id="BC">BC</span>
                            <span class="element-item" data-type="edge" data-id="CD">CD</span>
                            <span class="element-item" data-type="edge" data-id="DA">DA</span>
                            <span class="element-item" data-type="edge" data-id="EF">EF</span>
                            <span class="element-item" data-type="edge" data-id="FG">FG</span>
                            <span class="element-item" data-type="edge" data-id="GH">GH</span>
                            <span class="element-item" data-type="edge" data-id="HE">HE</span>
                            <span class="element-item" data-type="edge" data-id="AE">AE</span>
                            <span class="element-item" data-type="edge" data-id="BF">BF</span>
                            <span class="element-item" data-type="edge" data-id="CG">CG</span>
                            <span class="element-item" data-type="edge" data-id="DH">DH</span>
                        </div>
                    </div>
                    <div class="element-section">
                        <h4>–ì—Ä–∞–Ω–∏ (6):</h4>
                        <div class="element-list">
                            <span class="element-item" data-type="face" data-id="bottom">ABCD</span>
                            <span class="element-item" data-type="face" data-id="top">HGFE</span>
                            <span class="element-item" data-type="face" data-id="front">HEAD</span><br>
                            <span class="element-item" data-type="face" data-id="back">FGCB</span>
                            <span class="element-item" data-type="face" data-id="right">EFBA</span>
                            <span class="element-item" data-type="face" data-id="left">GHDC</span>
                        </div>
                    </div>
                `,
                'cylinder': `
                    <div class="element-section">
                        <h4>–≠–ª–µ–º–µ–Ω—Ç—ã:</h4>
                        <div class="element-list">
                            <span class="element-item" data-type="vertex" data-id="O1">O‚ÇÅ</span>
                            <span class="element-item" data-type="vertex" data-id="O2">O‚ÇÇ</span>
                            <span class="element-item" data-type="vertex" data-id="A">A</span><br>
                            <span class="element-item" data-type="vertex" data-id="B">B</span>
                            <span class="element-item" data-type="vertex" data-id="C">C</span>
                            <span class="element-item" data-type="vertex" data-id="D">D</span>
                        </div>
                    </div>
                    <div class="element-section">
                        <h4>–†–µ–±—Ä–∞:</h4>
                        <div class="element-list">
                            <span class="element-item" data-type="edge" data-id="O1O2">–í—ã—Å–æ—Ç–∞</span>
                            <span class="element-item" data-type="edge" data-id="O1A">–†–∞–¥–∏—É—Å</span>
                            <span class="element-item" data-type="edge" data-id="O2B">–†–∞–¥–∏—É—Å</span>
                        </div>
                    </div>
                    <div class="element-section">
                        <h4>–ì—Ä–∞–Ω–∏ (3):</h4>
                        <div class="element-list">
                            <span class="element-item" data-type="face" data-id="base1">–ù–∏–∂–Ω–µ–µ</span>
                            <span class="element-item" data-type="face" data-id="base2">–í–µ—Ä—Ö–Ω–µ–µ</span>
                            <span class="element-item" data-type="face" data-id="side">–ë–æ–∫–æ–≤–∞—è</span>
                        </div>
                    </div>
                `,
                'pyramid': `
                    <div class="element-section">
                        <h4>–í–µ—Ä—à–∏–Ω—ã (5):</h4>
                        <div class="element-list">
                            <span class="element-item" data-type="vertex" data-id="A">A</span>
                            <span class="element-item" data-type="vertex" data-id="B">B</span>
                            <span class="element-item" data-type="vertex" data-id="C">C</span><br>
                            <span class="element-item" data-type="vertex" data-id="D">D</span>
                            <span class="element-item" data-type="vertex" data-id="S">S</span>
                        </div>
                    </div>
                    <div class="element-section">
                        <h4>–†–µ–±—Ä–∞ (8):</h4>
                        <div class="element-list">
                            <span class="element-item" data-type="edge" data-id="AB">AB</span>
                            <span class="element-item" data-type="edge" data-id="BC">BC</span>
                            <span class="element-item" data-type="edge" data-id="CD">CD</span>
                            <span class="element-item" data-type="edge" data-id="DA">DA</span>
                            <span class="element-item" data-type="edge" data-id="AS">AS</span>
                            <span class="element-item" data-type="edge" data-id="BS">BS</span>
                            <span class="element-item" data-type="edge" data-id="CS">CS</span>
                            <span class="element-item" data-type="edge" data-id="DS">DS</span>
                        </div>
                    </div>
                    <div class="element-section">
                        <h4>–ì—Ä–∞–Ω–∏ (5):</h4>
                        <div class="element-list">
                            <span class="element-item" data-type="face" data-id="base">FBCD</span>
                            <span class="element-item" data-type="face" data-id="side1">ABS</span>
                            <span class="element-item" data-type="face" data-id="side2">BCS</span><br>
                            <span class="element-item" data-type="face" data-id="side3">CDS</span>
                            <span class="element-item" data-type="face" data-id="side4">DAS</span>
                        </div>
                    </div>
                `,
                'cone': `
                    <div class="element-section">
                        <h4>–≠–ª–µ–º–µ–Ω—Ç—ã:</h4>
                        <div class="element-list">
                            <span class="element-item" data-type="vertex" data-id="O">O</span>
                            <span class="element-item" data-type="vertex" data-id="S">S</span>
                            <span class="element-item" data-type="vertex" data-id="A">A</span>
                            <span class="element-item" data-type="vertex" data-id="B">B</span>
                        </div>
                    </div>
                    <div class="element-section">
                        <h4>–†–µ–±—Ä–∞:</h4>
                        <div class="element-list">
                            <span class="element-item" data-type="edge" data-id="OS">–í—ã—Å–æ—Ç–∞</span>
                            <span class="element-item" data-type="edge" data-id="OA">–†–∞–¥–∏—É—Å</span>
                            <span class="element-item" data-type="edge" data-id="OB">–†–∞–¥–∏—É—Å</span>
                        </div>
                    </div>
                    <div class="element-section">
                        <h4>–ì—Ä–∞–Ω–∏ (2):</h4>
                        <div class="element-list">
                            <span class="element-item" data-type="face" data-id="base">–û—Å–Ω–æ–≤–∞–Ω–∏–µ</span>
                            <span class="element-item" data-type="face" data-id="side">–ë–æ–∫–æ–≤–∞—è</span>
                        </div>
                    </div>
                `,
                'sphere': `
                    <div class="element-section">
                        <h4>–≠–ª–µ–º–µ–Ω—Ç—ã:</h4>
                        <div class="element-list">
                            <span class="element-item" data-type="vertex" data-id="O">–¶–µ–Ω—Ç—Ä</span>
                            <span class="element-item" data-type="vertex" data-id="N">–¢–æ—á–∫–∞ N</span>
                            <span class="element-item" data-type="vertex" data-id="S">–¢–æ—á–∫–∞ S</span>
                            <span class="element-item" data-type="vertex" data-id="E">–¢–æ—á–∫–∞ E</span>
                            <span class="element-item" data-type="edge" data-id="NS">–î–∏–∞–º–µ—Ç—Ä</span>
                            <span class="element-item" data-type="edge" data-id="OE">–†–∞–¥–∏—É—Å</span>
                        </div>
                    </div>
                   
                    <div class="element-section">
                        <h4>–ü–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç—å (1):</h4>
                        <div class="element-list">
                            <span class="element-item" data-type="face" data-id="surface">–ü–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç—å</span>
                        </div>
                    </div>
                `
            };

            elementsContent.innerHTML = panels[shapeType] || '';
            setupElementEventListeners();
        }

        // ==================== –ü–û–î–°–í–ï–¢–ö–ê –≠–õ–ï–ú–ï–ù–¢–û–í ====================
        function setupElementEventListeners() {
            clearAllTimeouts();
            document.querySelectorAll('.element-item').forEach(item => {
                item.addEventListener('click', (e) => highlightElement(e.target));
            });
        }

        function highlightElement(element) {
            const type = element.dataset.type;
            const id = element.dataset.id;
            
            // –°–Ω–∏–º–∞–µ–º –ø–æ–¥—Å–≤–µ—Ç–∫—É —Å–æ –≤—Å–µ—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –≤ –ø–∞–Ω–µ–ª–∏
            document.querySelectorAll('.element-item.highlighted').forEach(item => {
                item.classList.remove('highlighted');
            });
            
            // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–π –≤—ã–¥–µ–ª–µ–Ω–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç –≤ 3D —Å—Ü–µ–Ω–µ
            if (currentHighlightedElement) {
                restoreElement(currentHighlightedElement);
            }
            
            // –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–¥—Å–≤–µ—Ç–∫—É –Ω–æ–≤–æ–º—É —ç–ª–µ–º–µ–Ω—Ç—É –≤ –ø–∞–Ω–µ–ª–∏
            element.classList.add('highlighted');
            
            // –í—ã–¥–µ–ª—è–µ–º —ç–ª–µ–º–µ–Ω—Ç –≤ 3D —Å—Ü–µ–Ω–µ
            switch(type) {
                case 'vertex': highlightVertex(id); break;
                case 'edge': highlightEdge(id); break;
                case 'face': highlightFace(id); break;
            }
        }

        function highlightVertex(vertexId) {
            const vertex = vertexObjects.get(vertexId);
            if (vertex) {
                currentHighlightedElement = {
                    type: 'vertex',
                    id: vertexId,
                    originalColor: vertex.userData.originalColor,
                    originalScale: vertex.scale.clone()
                };
                
                // –£–±—Ä–∞–Ω–æ –∏–∑–º–µ–Ω–µ–Ω–∏–µ —Ü–≤–µ—Ç–∞, —Ç–æ–ª—å–∫–æ —É–≤–µ–ª–∏—á–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–∞
                vertex.scale.set(VERTEX_HIGHLIGHT_SCALE, VERTEX_HIGHLIGHT_SCALE, VERTEX_HIGHLIGHT_SCALE);
                
                highlightTimeouts.push(setTimeout(() => {
                    restoreElement(currentHighlightedElement);
                    currentHighlightedElement = null;
                }, HIGHLIGHT_DURATION));
            }
        }

        function highlightEdge(edgeId) {
            const edgeContainer = edgeObjects.get(edgeId);
            if (edgeContainer) {
                const userData = edgeContainer.userData;
                const edge = userData.child;
                
                currentHighlightedElement = {
                    type: 'edge',
                    id: edgeId,
                    edgeContainer: edgeContainer,
                    originalColor: edge.material.color.getHex(),
                    originalLinewidth: edge.material.linewidth,
                    originalScale: edgeContainer.scale.clone()
                };
                
                // –ú–µ–Ω—è–µ–º —Ü–≤–µ—Ç –∏ —Ç–æ–ª—â–∏–Ω—É
                edge.material.color.set(highlightColors[currentShapeName] || 0xFFA500);
                edge.material.linewidth = EDGE_HIGHLIGHT_WIDTH;
                edge.material.needsUpdate = true;
                
                // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Ä–µ–±—Ä–æ –≤ 2 —Ä–∞–∑–∞ —á–µ—Ä–µ–∑ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
                // –≠—Ç–æ —Å–æ—Ö—Ä–∞–Ω–∏—Ç –ø–æ–ª–æ–∂–µ–Ω–∏–µ —Ä–µ–±—Ä–∞ –Ω–∞ –º–µ—Å—Ç–µ
                edgeContainer.scale.multiplyScalar(EDGE_HIGHLIGHT_SCALE);
                
                highlightTimeouts.push(setTimeout(() => {
                    restoreElement(currentHighlightedElement);
                    currentHighlightedElement = null;
                }, HIGHLIGHT_DURATION));
            }
        }

        function highlightFace(faceId) {
            const face = faceObjects.get(faceId);
            if (face) {
                currentHighlightedElement = {
                    type: 'face',
                    id: faceId,
                    originalColor: face.userData.originalColor,
                    originalOpacity: face.userData.originalOpacity,
                    originalScale: face.scale ? face.scale.clone() : new THREE.Vector3(1, 1, 1),
                    originalPosition: face.position ? face.position.clone() : new THREE.Vector3()
                };
                
                // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –≥—Ä–∞–Ω—å –≤ 2 —Ä–∞–∑–∞
                if (face.scale) {
                    face.scale.multiplyScalar(2);
                }
                
                highlightTimeouts.push(setTimeout(() => {
                    restoreElement(currentHighlightedElement);
                    currentHighlightedElement = null;
                }, HIGHLIGHT_DURATION));
            }
        }

        function restoreElement(elementData) {
            if (!elementData) return;
            
            // –û—Ç–º–µ–Ω—è–µ–º –≤—Å–µ —Ç–∞–π–º–∞—É—Ç—ã
            clearAllTimeouts();
            
            switch(elementData.type) {
                case 'vertex':
                    const vertex = vertexObjects.get(elementData.id);
                    if (vertex) {
                        // –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ç–æ–ª—å–∫–æ –∏—Å—Ö–æ–¥–Ω—ã–π —Ä–∞–∑–º–µ—Ä, —Ü–≤–µ—Ç –Ω–µ –º–µ–Ω—è–µ–º
                        vertex.scale.copy(elementData.originalScale);
                    }
                    break;
                case 'edge':
                    if (elementData.edgeContainer) {
                        const edge = elementData.edgeContainer.userData.child;
                        edge.material.color.setHex(elementData.originalColor);
                        edge.material.linewidth = elementData.originalLinewidth;
                        edge.material.needsUpdate = true;
                        
                        // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∏—Å—Ö–æ–¥–Ω—ã–π –º–∞—Å—à—Ç–∞–±
                        elementData.edgeContainer.scale.copy(elementData.originalScale);
                    }
                    break;
                case 'face':
                    const face = faceObjects.get(elementData.id);
                    if (face) {
                        // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∏—Å—Ö–æ–¥–Ω—ã–π –º–∞—Å—à—Ç–∞–±
                        if (face.scale && elementData.originalScale) {
                            face.scale.copy(elementData.originalScale);
                        }
                    }
                    break;
            }
            
            // –£–±–∏—Ä–∞–µ–º –ø–æ–¥—Å–≤–µ—Ç–∫—É –≤ –ø–∞–Ω–µ–ª–∏
            document.querySelectorAll('.element-item.highlighted').forEach(item => {
                item.classList.remove('highlighted');
            });
        }

        // ==================== –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò ====================
        function updateLabels() {
            vertexLabels.forEach(item => {
                const screenPos = item.position.clone().project(camera);
                if (screenPos.z > 0 && screenPos.z < 1) {
                    const x = (screenPos.x * 0.5 + 0.5) * modalViewerContent.clientWidth;
                    const y = (-(screenPos.y * 0.5 + 0.5) + 1) * modalViewerContent.clientHeight;
                    item.element.style.display = 'block';
                    item.element.style.left = (x - 15) + 'px';
                    item.element.style.top = (y - 15) + 'px';
                } else {
                    item.element.style.display = 'none';
                }
            });
        }

        function onWindowResize() {
            if (camera && renderer && modalViewerContent.clientWidth > 0 && modalViewerContent.clientHeight > 0) {
                camera.aspect = modalViewerContent.clientWidth / modalViewerContent.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(modalViewerContent.clientWidth, modalViewerContent.clientHeight);
            }
        }

        function cleanupMesh(mesh) {
            if (!mesh) return;
            mesh.traverse(child => {
                if (child.isMesh) {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(material => material.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                }
            });
        }

        function updateModelName(name) {
            const nameElement = document.getElementById('current-model-name');
            if (nameElement) nameElement.textContent = name;
        }

        function centerCameraOnObject(object) {
            const box = new THREE.Box3().setFromObject(object);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = camera.fov * (Math.PI / 180);
            let cameraZ = Math.abs(maxDim / Math.sin(fov / 2)) * 1.5;
            camera.position.set(center.x, center.y, center.z + cameraZ);
            controls.target.set(center.x, center.y, center.z);
            controls.update();
        }

        function showModalViewer(shapeId) {
            if (!shapesConfig[shapeId]) return;
            modalViewer.classList.remove('hidden');
            document.body.style.overflow = 'hidden';
            if (!scene) init3DViewer();
            requestAnimationFrame(() => {
                createShape(shapeId);
                onWindowResize();
            });
        }

        function hideModalViewer() {
            modalViewer.classList.add('hidden');
            document.body.style.overflow = '';
            elementsPanel.classList.add('hidden');
        }

        // ==================== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ====================
        function setupEventListeners() {
            galleryCards.forEach(card => {
                card.addEventListener('click', () => showModalViewer(card.dataset.shape));
            });
            closeModalBtn.addEventListener('click', hideModalViewer);
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && !modalViewer.classList.contains('hidden')) hideModalViewer();
            });
            modalViewer.addEventListener('click', (e) => {
                if (e.target === modalViewer) hideModalViewer();
            });
        }

        document.addEventListener('DOMContentLoaded', setupEventListeners);
        window.addEventListener('beforeunload', () => {
            if (renderer) renderer.dispose();
            cleanupCurrentShape();
        });
    </script>
</body>
</html>